image: amazon/aws-cli:latest
clone:
  depth: full # SonarCloud scanner needs the full history to assign issues properly

definitions:
  caches:
    sonar: ~/.sonar/cache # Caching SonarCloud artifacts will speed up your build
  services:
    docker:
      memory: 3072
  steps:
    - step: &client-sonarcloud-analysis
        name: client-sonarcloud-analysis
        condition:
          changesets:
            includePaths:
              - "App/**"
        caches:
          - sonar
        script:
          - cd App
          - pipe: sonarsource/sonarcloud-scan:1.4.0
            variables:
              SONAR_TOKEN: ${SONAR_CLOUD_TOKEN}
              EXTRA_ARGS: '-Dsonar.organization="we-are-nova" -Dsonar.projectKey="${SONAR_CLOUD_BOARDWISE_APP_NAME}"'
              INCLUSIONS: "src/**"
              EXCLUSIONS: "/**/*.css,/**/*.scss,/test/**,/public/**,/build/**,/Dockerfile,/Dockerfile.local,/src/screens/coursewise/**"
              SONAR_SCANNER_OPTS: -Xmx256m
        services:
          - docker
    - step: &server-sonarcloud-analysis
        name: server-sonarcloud-analysis
        condition:
          changesets:
            includePaths:
              - "Server/**"
        image: mcr.microsoft.com/dotnet/sdk:6.0
        caches:
          - dotnetcore
          - sonar
        script:
          - cd Server 
          - apt-get update
          - apt-get install --yes openjdk-17-jre
          - dotnet tool install --global dotnet-sonarscanner
          - export PATH="$PATH:/root/.dotnet/tools"
          - dotnet sonarscanner begin /k:"${SONAR_CLOUD_BOARDWISE_API_NAME}" /d:"sonar.login=${SONAR_CLOUD_TOKEN_API}" /o:"we-are-nova" /v:"${BITBUCKET_COMMIT}"  /d:"sonar.host.url=https://sonarcloud.io" /d:sonar.exclusions=Coursewise.Api/Dockerfile,Coursewise.Data/SeedCoursewiseData.cs**,Coursewise.Data/Migrations/**
          - dotnet build
          - dotnet sonarscanner end /d:"sonar.login=${SONAR_CLOUD_TOKEN_API}"

pipelines:
  pull-requests:
    "**":
      - parallel:
        - step: *client-sonarcloud-analysis
        - step: *server-sonarcloud-analysis
  branches:
    master:
      #[Performing sonarscan]
      - parallel:
        - step: *client-sonarcloud-analysis  
        - step: *server-sonarcloud-analysis
       
      - step:
          name: Run Unit Tests for Api
          condition:
            changesets:
              includePaths:
                - "Server/**"
          image: mcr.microsoft.com/dotnet/sdk:6.0
          caches:
            - dotnetcore
          script:
            - cd Server
            - dotnet restore Coursewise.sln
            - dotnet build --no-restore --configuration Release
            - dotnet test --no-build --configuration Release
            
      #[Building images]
      - parallel:
          #[ Build Api Image]
          - step:
              name: Build and push Api
              condition:
                changesets:
                  includePaths:
                    - "Server/**"              
              script:
                # variables
                - IMAGE="$ECR_REGISTRY_URI_API:$BITBUCKET_BRANCH.$BITBUCKET_BUILD_NUMBER"
                - cd Server
                - yum install jq -y
                - jq --arg a "$BITBUCKET_BUILD_NUMBER" '.Nova.APIVersion = $a' Coursewise.Api/appsettings.json > "temp.json" && mv "temp.json" Coursewise.Api/appsettings.json
                
                - pwd
                - docker build -t $IMAGE -f Dockerfile .
                - aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_API
                - docker push "$IMAGE"
              filter:
                excludes:
                  - fargate-init-template.yaml
                  - fargate-webapp-template.yaml
                  - fargate-webapi-template.yaml
              services:
                - docker
              caches:
                - docker

          #[ Build WebApp Image]
          - step:
              name: Build and push WebApp
              condition:
                changesets:
                  includePaths:
                    - "App/**"
              size: 2x
              script:
                # variables
                - IMAGE="$ECR_REGISTRY_URI_WEB:$BITBUCKET_BRANCH.$BITBUCKET_BUILD_NUMBER"
                - cd App
                - docker build -t $IMAGE .
                - aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_WEB
                - docker push "$IMAGE"
              filter:
                excludes:
                  - fargate-init-template.yaml
                  - fargate-webapp-template.yaml
                  - fargate-webapi-template.yaml
              services:
                - docker
              caches:
                - docker
## ------------------ DEVELOPMENT DEPLOYMENT ------------------- ##
      - step:
          name: Dev-INIT-Stack - Initialize Dev
          condition:
            changesets:
              includePaths:
                - "Server/**"
                - "App/**"
          trigger: automatic
          script:
            # variables
            - Environment="development"                # change this as per new envionment              
            - INIT_STACK_NAME="Dev-INIT-Stack"          # change this as per new envionment

            - aws cloudformation deploy --template-file Fargate/fargate-init-template.yaml --stack-name $INIT_STACK_NAME --parameter-overrides Environment=$Environment ProjectName=$PROJECTNAME HostedZoneId=$HostedZoneId DomainName=$DomainName scheduleStop=$scheduleStop --region $Region --capabilities CAPABILITY_IAM

          artifacts:
            download: false

      - parallel:
          # deploy to development - web api
        - step:
            name: deploy to development - web api
            condition:
              changesets:
                includePaths:
                  - "Server/**"
            deployment: development-api
            trigger: automatic
            script:
              # variables
              - set +e
              - STACK_NAME="Dev-Webapi-Fargate-Stack"    # change this as per new envionment
              - Environment="development"                # change this as per new envionment              
              - EnvironmentFile=$EnvironmentFileDev       # change this as per new envionment
              - ApiImageUri="$ECR_REGISTRY_URI_API:$BITBUCKET_BRANCH.$BITBUCKET_BUILD_NUMBER"

              # Validate the ECR image
              - IMAGE="$ECR_REGISTRY_URI_API:$BITBUCKET_BRANCH.$BITBUCKET_BUILD_NUMBER"
              - REPOSITORY_NAME=$(echo "$ECR_REGISTRY_URI_API" | awk -F/ '{print $2}')
              - IMAGE_FOUND=null
              - DESCRIBE_ECR_IMAGE=$(aws ecr describe-images --repository-name $REPOSITORY_NAME --image-ids imageTag=$BITBUCKET_BRANCH.$BITBUCKET_BUILD_NUMBER --region $Region 2>&1 >/dev/null)
              - |
                if [[ $DESCRIBE_ECR_IMAGE == *"ImageNotFoundException"* ]]; then
                  IMAGE_FOUND="false"
                else
                  IMAGE_FOUND="true"
                fi
              - set -e
              - |
                if [[ $IMAGE_FOUND == "true" ]]; then
                  echo "Image found in ECR. Proceeding with deployment..."
                else
                  cd Server
                  yum install jq -y
                  jq --arg a "$BITBUCKET_BUILD_NUMBER" '.Nova.APIVersion = $a' Coursewise.Api/appsettings.json > "temp.json" && mv "temp.json" Coursewise.Api/appsettings.json

                  docker build -t $IMAGE -f Dockerfile .
                  aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_API
                  docker push "$IMAGE"
                  cd ..
                fi

              - aws cloudformation deploy --template-file Fargate/fargate-webapi-template.yaml --stack-name $STACK_NAME --parameter-overrides Environment=$Environment EnvironmentFile=$EnvironmentFileDev ProjectName=$PROJECTNAME ApiImageUri=$ApiImageUri HostedZoneId=$HostedZoneId DomainName=$DomainName --region $Region --capabilities CAPABILITY_IAM
            artifacts:
              download: false 
            services:
                - docker
            caches:
              - docker

          # deploy to development - web app
        - step:
            name: deploy to development - web app
            condition:
              changesets:
                includePaths:
                  - "App/**"
            deployment: development-app
            trigger: automatic
            script:
              # variables
              - STACK_NAME="Dev-Webapp-Fargate-Stack"    # change this as per new envionment
              - Environment="development"                # change this as per new envionment
              - EnvironmentFile=$EnvironmentFileDev       # change this as per new envionment 
              - WebImageUri="$ECR_REGISTRY_URI_WEB:$Environment.$BITBUCKET_BUILD_NUMBER"

              - set +e
              - IMAGE="$ECR_REGISTRY_URI_WEB:$Environment.$BITBUCKET_BUILD_NUMBER"
              # Validate the ECR image
              - REPOSITORY_NAME=$(echo "$ECR_REGISTRY_URI_WEB" | awk -F/ '{print $2}')
              - IMAGE_FOUND=null
              - DESCRIBE_ECR_IMAGE=$(aws ecr describe-images --repository-name $REPOSITORY_NAME --image-ids imageTag=$Environment.$BITBUCKET_BUILD_NUMBER --region $Region 2>&1 >/dev/null)
              - |
                if [[ $DESCRIBE_ECR_IMAGE == *"ImageNotFoundException"* ]]; then
                  IMAGE_FOUND="false"
                else
                  IMAGE_FOUND="true"
                fi
              - set -e
              - |
                if [[ $IMAGE_FOUND == "true" ]]; then
                  echo "Image found in ECR. Proceeding with deployment..."
                else
                  cd App
                  docker build -t $IMAGE -f Dockerfile .
                  aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_WEB
                  docker push "$IMAGE"
                  cd ..
                fi

              - aws cloudformation deploy --template-file Fargate/fargate-webapp-template.yaml --stack-name $STACK_NAME --parameter-overrides Environment=$Environment EnvironmentFile=$EnvironmentFileDev ProjectName=$PROJECTNAME WebImageUri=$WebImageUri HostedZoneId=$HostedZoneId DomainName=$DomainName --region $Region --capabilities CAPABILITY_IAM
            artifacts:
              download: false 
            services:
              - docker
            caches:
              - docker

##-----------------SmokeTestSheet---------------------##



  default:
    - step:
        image: node:18
        script:
          - npm install
          - node downloadSmokeTestSheet.js
          - git add smoke_test_sheet.xlsx
          - git commit -m "[skip ci] Smoke Test sheet updated. Automated."
          - git push
     
## ------------------ STAGING DEPLOYMENT ------------------- ##  
    - step:
          name: Stag-INIT-Stack - Initialize Stag
          condition:
            changesets:
              includePaths:
                - "Server/**"
                - "App/**"
          trigger: manual
          script:
            # variables
            - ApiImageUri="$ECR_REGISTRY_URI_API:$BITBUCKET_BRANCH.$BITBUCKET_BUILD_NUMBER"
            - Environment="staging"                     # change this as per new envionment
            - INIT_STACK_NAME="Stag-INIT-Stack"         # change this as per new envionment

            - aws cloudformation deploy --template-file Fargate/fargate-init-template.yaml --stack-name $INIT_STACK_NAME --parameter-overrides Environment=$Environment ProjectName=$PROJECTNAME HostedZoneId=$HostedZoneId DomainName=$DomainName scheduleStop=$scheduleStop --region $Region --capabilities CAPABILITY_IAM

    - parallel:
          # deploy to staging - web api
        - step:
            name: deploy to staging - web api
            condition:
              changesets:
                includePaths:
                  - "Server/**"
            deployment: staging-api
            trigger: automatic
            script:
              # variables
              - STACK_NAME="Stag-Webapi-Fargate-Stack"    # change this as per new envionment
              - Environment="staging"                     # change this as per new envionment
              - EnvironmentFile=$EnvironmentFileStag    # change this as per new envionment
              - ApiImageUri="$ECR_REGISTRY_URI_API:$Environment.$BITBUCKET_BUILD_NUMBER"

              - set +e
              - IMAGE="$ECR_REGISTRY_URI_API:$Environment.$BITBUCKET_BUILD_NUMBER"
              # Validate the ECR image
              - REPOSITORY_NAME=$(echo "$ECR_REGISTRY_URI_API" | awk -F/ '{print $2}')
              - IMAGE_FOUND=null
              - DESCRIBE_ECR_IMAGE=$(aws ecr describe-images --repository-name $REPOSITORY_NAME --image-ids imageTag=$Environment.$BITBUCKET_BUILD_NUMBER --region $Region 2>&1 >/dev/null)
              - |
                if [[ $DESCRIBE_ECR_IMAGE == *"ImageNotFoundException"* ]]; then
                  IMAGE_FOUND="false"
                else
                  IMAGE_FOUND="true"
                fi
              - set -e
              - |
                if [[ $IMAGE_FOUND == "true" ]]; then
                  echo "Image found in ECR. Proceeding with deployment..."
                else
                  cd Server
                  yum install jq -y
                  jq --arg a "$BITBUCKET_BUILD_NUMBER" '.Nova.APIVersion = $a' Coursewise.Api/appsettings.json > "temp.json" && mv "temp.json" Coursewise.Api/appsettings.json

                  docker build -t $IMAGE -f Dockerfile .
                  aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_API
                  docker push "$IMAGE"
                  cd ..
                fi

              - aws cloudformation deploy --template-file Fargate/fargate-webapi-template.yaml --stack-name $STACK_NAME --parameter-overrides Environment=$Environment EnvironmentFile=$EnvironmentFile ProjectName=$PROJECTNAME ApiImageUri=$ApiImageUri HostedZoneId=$HostedZoneId DomainName=$DomainName --region $Region --capabilities CAPABILITY_IAM
            artifacts:
              download: false 
            services:
              - docker
            caches:
              - docker

          # deploy to staging - web app
        - step:
            name: deploy to staging - web app
            condition:
              changesets:
                includePaths:
                  - "App/**"
            deployment: staging-app
            trigger: automatic
            script:
              # variables
              - STACK_NAME="Stag-Webapp-Fargate-Stack"    # change this as per new envionment
              - Environment="staging"                     # change this as per new envionment
              - EnvironmentFile=$EnvironmentFileStag      # change this as per new envionment
              - WebImageUri="$ECR_REGISTRY_URI_WEB:$Environment.$BITBUCKET_BUILD_NUMBER"

              - set +e
              - IMAGE="$ECR_REGISTRY_URI_WEB:$Environment.$BITBUCKET_BUILD_NUMBER"
              # Validate the ECR image
              - REPOSITORY_NAME=$(echo "$ECR_REGISTRY_URI_WEB" | awk -F/ '{print $2}')
              - IMAGE_FOUND=null
              - DESCRIBE_ECR_IMAGE=$(aws ecr describe-images --repository-name $REPOSITORY_NAME --image-ids imageTag=$Environment.$BITBUCKET_BUILD_NUMBER --region $Region 2>&1 >/dev/null)
              - |
                if [[ $DESCRIBE_ECR_IMAGE == *"ImageNotFoundException"* ]]; then
                  IMAGE_FOUND="false"
                else
                  IMAGE_FOUND="true"
                fi
              - set -e
              - |
                if [[ $IMAGE_FOUND == "true" ]]; then
                  echo "Image found in ECR. Proceeding with deployment..."
                else
                  cd App
                  docker build -t $IMAGE -f Dockerfile .
                  aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_WEB
                  docker push "$IMAGE"
                  cd ..
                fi

              - aws cloudformation deploy --template-file Fargate/fargate-webapp-template.yaml --stack-name $STACK_NAME --parameter-overrides Environment=$Environment EnvironmentFile=$EnvironmentFile ProjectName=$PROJECTNAME WebImageUri=$WebImageUri HostedZoneId=$HostedZoneId DomainName=$DomainName --region $Region --capabilities CAPABILITY_IAM
            artifacts:
              download: false 
            services:
                - docker
            caches:
              - docker

## ------------------ Production DEPLOYMENT ------------------- ##  
    - step:
          name: Prod-INIT-Stack - Initialize Prod
          condition:
            changesets:
              includePaths:
                - "Server/**"
                - "App/**"
          trigger: manual
          script:
            # variables
            - ApiImageUri="$ECR_REGISTRY_URI_API:$BITBUCKET_BRANCH.$BITBUCKET_BUILD_NUMBER"
            - Environment="production"                     # change this as per new envionment
            - INIT_STACK_NAME="Prod-INIT-Stack"         # change this as per new envionment

            - aws cloudformation deploy --template-file Fargate/fargate-init-template.yaml --stack-name $INIT_STACK_NAME --parameter-overrides Environment=$Environment ProjectName=$PROJECTNAME HostedZoneId=$HostedZoneId DomainName=$DomainName scheduleStop=$scheduleStop --region $Region --capabilities CAPABILITY_IAM

    - parallel:
          # deploy to production - web api
        - step:
            name: deploy to production - web api
            condition:
              changesets:
                includePaths:
                  - "Server/**"
            deployment: production-api
            trigger: automatic
            script:
              # variables
              - STACK_NAME="Prod-Webapi-Fargate-Stack"    # change this as per new envionment
              - Environment="production"                     # change this as per new envionment
              - EnvironmentFile=$EnvironmentFileProd    # change this as per new envionment
              - ApiImageUri="$ECR_REGISTRY_URI_API:$Environment.$BITBUCKET_BUILD_NUMBER"

              - set +e
              - IMAGE="$ECR_REGISTRY_URI_API:$Environment.$BITBUCKET_BUILD_NUMBER"
              # Validate the ECR image
              - REPOSITORY_NAME=$(echo "$ECR_REGISTRY_URI_API" | awk -F/ '{print $2}')
              - IMAGE_FOUND=null
              - DESCRIBE_ECR_IMAGE=$(aws ecr describe-images --repository-name $REPOSITORY_NAME --image-ids imageTag=$Environment.$BITBUCKET_BUILD_NUMBER --region $Region 2>&1 >/dev/null)
              - |
                if [[ $DESCRIBE_ECR_IMAGE == *"ImageNotFoundException"* ]]; then
                  IMAGE_FOUND="false"
                else
                  IMAGE_FOUND="true"
                fi
              - set -e
              - |
                if [[ $IMAGE_FOUND == "true" ]]; then
                  echo "Image found in ECR. Proceeding with deployment..."
                else
                  cd Server
                  yum install jq -y
                  jq --arg a "$BITBUCKET_BUILD_NUMBER" '.Nova.APIVersion = $a' Coursewise.Api/appsettings.json > "temp.json" && mv "temp.json" Coursewise.Api/appsettings.json

                  docker build -t $IMAGE -f Dockerfile .
                  aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_API
                  docker push "$IMAGE"
                  cd ..
                fi

              - aws cloudformation deploy --template-file Fargate/fargate-webapi-template.yaml --stack-name $STACK_NAME --parameter-overrides Environment=$Environment EnvironmentFile=$EnvironmentFile ProjectName=$PROJECTNAME ApiImageUri=$ApiImageUri HostedZoneId=$HostedZoneId DomainName=$DomainName --region $Region --capabilities CAPABILITY_IAM
            artifacts:
              download: false 
            services:
              - docker
            caches:
              - docker

          # deploy to production - web app
        - step:
            name: deploy to production - web app
            condition:
              changesets:
                includePaths:
                  - "App/**"
            deployment: production-app
            trigger: automatic
            script:
              # variables
              - STACK_NAME="Prod-Webapp-Fargate-Stack"    # change this as per new envionment
              - Environment="production"                     # change this as per new envionment
              - EnvironmentFile=$EnvironmentFileProd      # change this as per new envionment
              - WebImageUri="$ECR_REGISTRY_URI_WEB:$Environment.$BITBUCKET_BUILD_NUMBER"

              - set +e
              - IMAGE="$ECR_REGISTRY_URI_WEB:$Environment.$BITBUCKET_BUILD_NUMBER"
              # Validate the ECR image
              - REPOSITORY_NAME=$(echo "$ECR_REGISTRY_URI_WEB" | awk -F/ '{print $2}')
              - IMAGE_FOUND=null
              - DESCRIBE_ECR_IMAGE=$(aws ecr describe-images --repository-name $REPOSITORY_NAME --image-ids imageTag=$Environment.$BITBUCKET_BUILD_NUMBER --region $Region 2>&1 >/dev/null)
              - |
                if [[ $DESCRIBE_ECR_IMAGE == *"ImageNotFoundException"* ]]; then
                  IMAGE_FOUND="false"
                else
                  IMAGE_FOUND="true"
                fi
              - set -e
              - |
                if [[ $IMAGE_FOUND == "true" ]]; then
                  echo "Image found in ECR. Proceeding with deployment..."
                else
                  cd App
                  docker build -t $IMAGE -f Dockerfile .
                  aws ecr get-login-password --region $Region | docker login --username AWS --password-stdin $ECR_REGISTRY_URI_WEB
                  docker push "$IMAGE"
                  cd ..
                fi

              - aws cloudformation deploy --template-file Fargate/fargate-webapp-template.yaml --stack-name $STACK_NAME --parameter-overrides Environment=$Environment EnvironmentFile=$EnvironmentFile ProjectName=$PROJECTNAME WebImageUri=$WebImageUri HostedZoneId=$HostedZoneId DomainName=$DomainName --region $Region --capabilities CAPABILITY_IAM
            artifacts:
              download: false 
            services:
              - docker
            caches:
              - docker                            